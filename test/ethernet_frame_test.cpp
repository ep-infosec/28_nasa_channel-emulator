/* -*- C++ -*- */

//=============================================================================
/**
 * @file   ethernet_frame_test.cpp
 * @author Tad Kollar <>
 *
 * $Id: ethernet_frame_test.cpp 1670 2012-08-28 13:25:28Z tkollar $ 
 * Copyright (c) 2008.
 *      NASA Glenn Research Center.  All rights reserved.
 *      See COPYING file that comes with this distribution.
 */
//=============================================================================

#include "EthernetFrame.hpp"
#include "MacAddress.hpp"
#include "Dot1qFrame.hpp"
#include "IPv4_UDP_Datagram.hpp"
#include <iostream>
#include <iomanip>

using namespace nasaCE;
using namespace std;

void print_vlan_info(Dot1qFrame* frame) {
		cout << "    802.1q Tag: " << hex << uppercase << setw(4) << setfill('0') << frame->getTag() << endl
			 << "   802.1q Type: " << hex << uppercase << setw(4) << setfill('0') << frame->getEther8021qType() << endl;
}

void print_info(EthernetFrame* frame) {
	MacAddress dstAddr(frame->ptrDstAddr()), srcAddr(frame->ptrSrcAddr());

	cout << endl
		 << "    Frame Type: " << frame->typeStr() << endl
		 << "      Preamble: " << hex << uppercase << setw(4) << setfill('0') << frame->getPreamble() << endl
		 << " Preamble Type: " << hex << uppercase << setw(4) << setfill('0') << frame->getPreambleType() << endl
		 << "      Dst. MAC: " << dstAddr.addr2str() << endl
		 << "      Src. MAC: " << srcAddr.addr2str() << endl
		 << " Ethernet Type: " << hex << uppercase << setw(4) << setfill('0') << frame->getEtherType() << endl
		 << "  Payload Type: " << hex << uppercase << setw(4) << setfill('0') << frame->getPayloadType() << endl
		 << "   Type String: " << frame->getEtherTypeStr() << endl
		 << "Payload Length: " << frame->extractPayloadLength() << endl
		 << "       Is ARP?: " << ((frame->isArp())? "Yes" : "No") << endl
		 << "      Is VLAN?: " << ((frame->is8021q())? "Yes" : "No") << endl;
	 
	if ( frame->is8021q() ) { print_vlan_info((Dot1qFrame*) frame); }
	
	cout << endl;
};

int main() {
	// An ethernet frame containing an IPv4/ICMP packet.
	ACE_UINT8 enet_buf_ipv4[102] = {
		0x00, 0x00, 0x08, 0x00, 0x00, 0x30, 0x48, 0x57, 0x6C, 0x3F, 0x00, 0x30,
		0x48, 0x57, 0x6C, 0x27, 0x08, 0x00, 0x45, 0x00, 0x00, 0x54, 0x00, 0x00,
		0x40, 0x00, 0x40, 0x01, 0x22, 0xB1, 0x0A, 0xFA, 0x01, 0x02, 0x0A, 0xFA,
		0x01, 0x03, 0x08, 0x00, 0x16, 0xFF, 0xB8, 0x6B, 0x00, 0x01, 0xA7, 0x63,
		0x59, 0x48, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x15, 0x0E, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
		0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
		0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x35, 0x36, 0x37
	};

	EthernetFrame* enetIPv4 = new EthernetFrame(EthernetFrame::LinuxTap);
	enetIPv4->replicateBuffer(enet_buf_ipv4, 102);
	enetIPv4->dump();
	print_info(enetIPv4);
	
	IPv4Packet* pkt = enetIPv4->wrapInnerPDU<IPv4Packet>();
	pkt->release();
	
	pkt = enetIPv4->wrapInnerPDU<IPv4_UDP_Datagram>();
	
	enetIPv4->release();
	pkt->getIPE_Header_Val();
	pkt->dump();
	
	pkt->release();
	
	exit(0);
	
	// An ethernet frame containing an ARP packet.
	ACE_UINT8 enet_buf_arp[64] = {
		0x00, 0x00, 0x08, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x30,
		0x48, 0x57, 0x6C, 0x27, 0x08, 0x06, 0x00, 0x01, 0x08, 0x00, 0x06, 0x04,
		0x00, 0x01, 0x00, 0x30, 0x48, 0x57, 0x6C, 0x27, 0x0A, 0xFA, 0x01, 0x02,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xFA, 0x01, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
			  
	EthernetFrame* enetARP = new EthernetFrame(EthernetFrame::LinuxTap);
	enetARP->replicateBuffer(enet_buf_arp, 64);
	enetARP->dump();
	print_info(enetARP);
	
	// An ethernet frame with an 802.1q tag.
	ACE_UINT8 enet_buf_dot1q[106] = {
		0x00, 0x00, 0x81, 0x00,	0x00, 0x30, 0x48, 0x57, 0x6c, 0x27, 0x00, 0x30,
		0x48, 0x57, 0x6c, 0x3f, 0x81, 0x00, 0x00, 0x63, 0x08, 0x00, 0x45, 0x00,
		0x00, 0x54, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0x29, 0x54, 0xc0, 0xa8,
		0xc8, 0x02, 0xc0, 0xa8, 0xc8, 0x01, 0x08, 0x00, 0x4d, 0x39, 0xd1, 0x0c,
		0x00, 0x01, 0x7c, 0x0f, 0xd1, 0x48, 0x00, 0x00, 0x00, 0x00, 0xc5, 0x8d,
		0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
		0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
		0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
		0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
	};
	
	EthernetFrame* enetDot1Q = new Dot1qFrame(EthernetFrame::LinuxTap);
	enetDot1Q->replicateBuffer(enet_buf_dot1q, 106);
	enetDot1Q->dump();
	print_info(enetDot1Q);
	
	EthernetFrame* frontBackTest = new EthernetFrame(EthernetFrame::LinuxTap);
	frontBackTest->setFront(enet_buf_ipv4);
	frontBackTest->setBack(enet_buf_ipv4 + EthernetFrame::minBytesToDetermineLength(),
		102 - EthernetFrame::minBytesToDetermineLength());
	frontBackTest->dump();
	print_info(frontBackTest);
}
