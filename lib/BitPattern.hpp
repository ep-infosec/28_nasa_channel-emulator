/* -*- C++ -*- */

//=============================================================================
/**
 * @file   BitPattern.hpp
 * @author Tad Kollar  
 *
 * $Id: BitPattern.hpp 2364 2013-09-17 19:41:51Z tkollar $
 * Copyright (c) 2008-2013.
 *      NASA Glenn Research Center.  All rights reserved.
 *      See COPYING file that comes with this distribution.
 */
//=============================================================================

#ifndef _NASA_BIT_PATTERN_HPP_
#define _NASA_BIT_PATTERN_HPP_

#include <cstdlib>
#include "NetworkData.hpp"

namespace nasaCE {

//=============================================================================
/**
 * @class BitPattern
 * @author Tad Kollar < >
 * @brief Base class for all types of bit patterns.
*/
//=============================================================================
class BitPattern {
public:
	/// Constructor.
	/// @param patternBitLen The intended bit length of the pattern.
	/// @param wordBits The number of bits in one word, required by some patterns.
	BitPattern(const size_t patternBitLen, const size_t wordBits = 8);

	/// Destructor.
	virtual ~BitPattern();

	/// @brief Create a buffer of specified length and fill it with the local pattern.
	/// The buffer object is managed by the requester.
	/// @param bufLen Length of the buffer to create.
	/// @param restart Begin copying from bit 0
	/// @throw OutOfMemory If the buffer cannot be allocated.
	/// @return Pointer to the new buffer.
	virtual NetworkData* makeNewPatternBuffer(const size_t bufLen, const bool restart = false);

	/// Read-only accessor to wordBits_.
	size_t getWordBits() { return wordBits_; }

	/// Read-only accessor to pattern_.
	NetworkData* getPattern();

	/// Read-only accessor to patternBitLen_.
	size_t getPatternBitLen() const;

	/// Return the number of bytes required to hold the pattern.
	size_t getPatternByteLen() const;

	/// String representation of the pattern type.
	virtual std::string getTypeStr() const;

	/// Retrieve the value of a bit in the specified word.
	/// @param word The index of the word to examine.
	/// @param bit The index within the word of the bit to return.
	bool getWordBit(const size_t word, const size_t bit) const;

	/// Set the value of a bit in the specified word.
	/// @param word The index of the word to modify.
	/// @param bit The index within the word of the bit to set.
	/// @param val The new value of the bit.
	/// @return The value of the bit just set.
	bool setWordBit(const size_t word, const size_t bit, const bool val) const;

	/// Copy the specified word to another word within the same pattern.
	/// @param srcIdx The index of the word to copy from.
	/// @param dstIdx The index of the word to copy to.
	void copyWord(const size_t srcIdx, const size_t dstIdx);

	/// Left-shift the specified word the specified number of positions.
	/// @param word The index of the word to modify.
	/// @param positions The number of positions to shift, up to the size of the word.
	void lshWord(const size_t word, const size_t positions);

	/// Right-shift the specified word the specified number of positions.
	/// @param word The index of the word to modify.
	/// @param positions The number of positions to shift, up to the size of the word.
	void rshWord(const size_t word, const size_t positions);

	/// @brief Copy a portion of one word into another word.
	/// In the case of a would-be overrun, bits are just not ignored.
	/// @param srcWord The index of the word to copy from.
	/// @param srcBit The bit in the source word to begin copying from.
	/// @param len The number of bits to copy.
	/// @param dstWord The index of the word to copy into.
	/// @param dstBit The index of the first bit to begin writing to.
	void copySubWord(const size_t srcWord, const size_t srcBit, const size_t len,
		const size_t dstWord, const size_t dstBit);

	/// Convert the specified word, up to 64-bits in length, into an unsigned long.
	/// /// @param word The index of the word to convert.
	unsigned long word2Long(const size_t word);

protected:
	/// The number of bits in one word, required by some patterns.
	size_t wordBits_;

	/// Holds the pattern for reuse, if applicable.
	NetworkData* pattern_;

	/// Number of bits in the pattern (may be smaller than what is stored in pattern_).
	size_t patternBitLen_;

	/// Where the last copy operation left off.
	size_t nextBitToCopy_;

	static ACE_UINT8 bitMask_[8];
	static ACE_UINT8 invBitMask_[8];
};

//=============================================================================
/**
 * @class EntropyPattern
 * @author Tad Kollar < >
 * @brief Fill pattern space with random bytes from entropy generated by system events.
*/
//=============================================================================
class EntropyPattern: public BitPattern {
public:
	/// Constructor.
	/// @param patternBitLen The intended bit length of the pattern.
	EntropyPattern(const size_t patternBitLen = 2048);

	/// String representation of the pattern type.
	std::string getTypeStr() const;

private:

	/// Use /dev/urandom to fill the pattern buffer.
	/// @throw nd_error If there is an open/read error.
	void _getEntropy();

	/// Use rand() to fill the pattern buffer. Only called when _getEntropy() throws an error.
	void _getPseudoRandom();
};

//=============================================================================
/**
 * @class AllOnesPattern
 * @author Tad Kollar < >
 * @brief Fill pattern space with all ones.
*/
//=============================================================================
class AllOnesPattern: public BitPattern {
public:
	/// Constructor.
	AllOnesPattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class AllZeroesPattern
 * @author Tad Kollar < >
 * @brief Fill pattern space with all zeroes.
*/
//=============================================================================
class AllZeroesPattern: public BitPattern {
public:
	/// Constructor.
	AllZeroesPattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class OnesAndZeroesPattern
 * @author Tad Kollar < >
 * @brief Fill pattern space with alternating zeroes and ones.
*/
//=============================================================================
class OnesAndZeroesPattern: public BitPattern {
public:
	/// Constructor.
	OnesAndZeroesPattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class S3In24Pattern
 * @author Tad Kollar < >
 * @brief Pattern of 3 ones amid 21 zeroes, no more than 15 zeroes together.
*/
//=============================================================================
class S3In24Pattern: public BitPattern {
public:
	/// Constructor.
	S3In24Pattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class S1In8Pattern
 * @author Tad Kollar < >
 * @brief Pattern with a one and seven zeroes.
*/
//=============================================================================
class S1In8Pattern: public BitPattern {
public:
	/// Constructor.
	S1In8Pattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class S2In8Pattern
 * @author Tad Kollar < >
 * @brief Pattern with two ones and six zeroes.
*/
//=============================================================================
class S2In8Pattern: public BitPattern {
public:
	/// Constructor.
	S2In8Pattern();

	/// String representation of the pattern type.
	std::string getTypeStr() const;
};

//=============================================================================
/**
 * @class PrbsPattern
 * @author Tad Kollar < >
 * @brief n-bit pseudorandom pattern.
*/
//=============================================================================
class PrbsPattern: public BitPattern {
public:
	/// Constructor.
	/// @param shifterBits The number of bits in the shifter, yielding a (1<<shifterBits - 1)*shifterBits bit pattern.
	PrbsPattern(const size_t shifterBits);

	/// String representation of the pattern type.
	std::string getTypeStr() const;

private:
	/// Load the pattern into the buffer.
	void _genPattern();

	/// Populate the specified word in the pattern by left shifting the one
	/// before it and performing exclusive-ORs on the tap indices.
	/// @param word Index of the word in the pattern to generate.
	/// @param taps Array of bit indexes to XOR with.
	/// @param tapCount Length of taps array
	void _genWordLsh(const size_t word, int taps[], const size_t tapCount);

	/// Populate the specified word in the pattern by right shifting the one
	/// before it and performing exclusive-ORs on the tap indices.
	/// @param word Index of the word in the pattern to generate.
	/// @param taps Array of bit indexes to XOR with.
	/// @param tapCount Length of taps array
	void _genWordRsh(const size_t word, int taps[], const size_t tapCount);


};

} // namespace nasaCE

#endif // _NASA_BIT_PATTERN_HPP_
